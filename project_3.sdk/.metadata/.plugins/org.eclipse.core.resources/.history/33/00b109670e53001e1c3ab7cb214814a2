
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "stdio.h"
#include <xuartlite.h>
#include <xparameters.h>

#include "platform.h"
#include "xil_io.h"

#define uart_id XPAR_UARTLITE_0_DEVICE_ID
#define MAX_STRING_SIZE 32
#define MAX_LENGHT 128


XUartLite uart;


int n = 0;
int global_string_pointer = 0;

char recieve_msg [MAX_STRING_SIZE];
char recieve_char;


int point_n = 0;
int point_m = 0;

char msg_n[] = "Hello, enter huenter";
char msg_matrix[] = "Start to enter matrix";
size_t matrix_count = 0;


void display_step(int step){
	switch (step){
		case 0:
			Xil_Out8(0x40000000, 19); // N
			break;
		case 1:
			Xil_Out8(0x40000000, 17); // A
			break;
		case 2:
			Xil_Out8(0x40000000, 0); // B
			break;
	}
}

void calc_result(){
  int c_matrix[7][7] = {-1};
  int c_temp = 0;

  for(int i = 0; i < n ; i++){
	  for(int j = 0; j < n ; j++){
		  for(int r = 0; r < n ; r++){
		      c_temp += matrix[0][i][r] * matrix[1][r][j];
		  }
		  c_matrix[i][j] = c_temp;
	  }
  }
}

void reset(){
  n = 0;
  point_n = 0;
  point_m = 0;
  global_string_pointer = 0;
}

int get_number(char* line, size_t len){
  int num = 0;
  int mul = 1;
  for (int i = len - 1; i >= 0; i--){
	  num += (line[i] - '0') * mul;
    mul *= 10;
  }
  return num;
}

/*
void uart_receive(void *CallBackRef, unsigned int ByteCount){

  char cur_char [1] = {recieve_char};

  XUartLite_Send(&uart, cur_char, 1);

  if(recieve_char == ' '){
    int cur_num = get_number();
    if (n == 0){
      n = cur_num;
      display_step(1);
      XUartLite_Send(&uart, msg_matrix, sizeof(msg_matrix));
    } else{
      if(point_n >= n){
    	point_m++;
    	point_n = 0;
      }
      matrix[matrix_count][point_m][point_n++] = cur_num;
    }
    global_string_pointer = 0;

    if(point_n == n-1 && point_m == n-1){

      if (++matrix_count == 2){
    	  matrix_count = 0;
    	  calc_result();
      }else{
    	  display_step(2);
      }
      reset();
    }

  } else {
    recieve_msg[global_string_pointer++] = recieve_char;
  }

  //XUartLite_SetRecvHandler(&uart, recieve_matrix, &uart);

  //XUartLite_Recv(&uart, &recieve_n_char, 1);

}
*/

int main()
{
	init_platform();
	XUartLite_Initialize(&uart, uart_id);
	//XUartLite_EnableInterrupt(&uart);

  //XUartLite_SetRecvHandler(&uart, uart_receive, &uart);

  //Xil_Out8(0x40000000, 1); // выбираем правый семисегментник (анод = 1)
  //display_step(0);

  //XUartLite_Send(&uart, msg_n, sizeof(msg_n));



  //XUartLite_Recv(&uart, &recieve_char, 1);

  printf("%s", msg_n);
  scanf("%d", &n);
  printf("%d", n);

  int matrix [2][n][n];

  char c = '\0';
  char line[MAX_LENGHT] = {0};
  size_t pointer = 0;
  for(;;){
	  while (c != '\n'){
		  scanf("%c", &c);
		  printf("%c", c);
		  if (c == ' '){
			  printf("\n%d\n", get_number(line, pointer));
			  pointer = 0;
			  memset(line,0,MAX_LENGHT);
		  }else{
			  line[pointer++] = c;
		  }

	  }


  }


    cleanup_platform();
    return 0;
}
